// src/hooks/useApi.js\nimport { useState, useCallback } from 'react';\n\n/**\n * Generic hook for API operations with loading and error states\n * @param {Function} apiFunction - The API function to execute\n * @param {Object} options - Hook options\n * @returns {Object} API state and execute function\n */\nexport const useApi = (apiFunction, options = {}) => {\n  const { onSuccess, onError, initialData = null } = options;\n  \n  const [data, setData] = useState(initialData);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const execute = useCallback(async (...args) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await apiFunction(...args);\n      setData(result);\n      \n      if (onSuccess) {\n        onSuccess(result);\n      }\n      \n      return result;\n    } catch (err) {\n      setError(err.message || 'An error occurred');\n      \n      if (onError) {\n        onError(err);\n      }\n      \n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [apiFunction, onSuccess, onError]);\n\n  const reset = useCallback(() => {\n    setData(initialData);\n    setError(null);\n    setLoading(false);\n  }, [initialData]);\n\n  return {\n    data,\n    loading,\n    error,\n    execute,\n    reset,\n    clearError: () => setError(null)\n  };\n};\n\n/**\n * Hook for managing paginated API calls\n * @param {Function} apiFunction - The API function for fetching data\n * @param {Object} options - Pagination options\n * @returns {Object} Pagination state and controls\n */\nexport const usePaginatedApi = (apiFunction, options = {}) => {\n  const { pageSize = 10, initialPage = 1 } = options;\n  \n  const [data, setData] = useState([]);\n  const [totalPages, setTotalPages] = useState(0);\n  const [totalItems, setTotalItems] = useState(0);\n  const [currentPage, setCurrentPage] = useState(initialPage);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const fetchPage = useCallback(async (page = currentPage, params = {}) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await apiFunction({\n        page,\n        limit: pageSize,\n        ...params\n      });\n      \n      // Assuming the API returns { data, total, totalPages, currentPage }\n      setData(result.data || result);\n      setTotalPages(result.totalPages || Math.ceil((result.total || 0) / pageSize));\n      setTotalItems(result.total || 0);\n      setCurrentPage(result.currentPage || page);\n      \n      return result;\n    } catch (err) {\n      setError(err.message || 'Failed to fetch data');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [apiFunction, pageSize, currentPage]);\n\n  const goToPage = useCallback((page) => {\n    if (page >= 1 && page <= totalPages) {\n      fetchPage(page);\n    }\n  }, [fetchPage, totalPages]);\n\n  const nextPage = useCallback(() => {\n    if (currentPage < totalPages) {\n      goToPage(currentPage + 1);\n    }\n  }, [currentPage, totalPages, goToPage]);\n\n  const prevPage = useCallback(() => {\n    if (currentPage > 1) {\n      goToPage(currentPage - 1);\n    }\n  }, [currentPage, goToPage]);\n\n  const refresh = useCallback(() => {\n    fetchPage(currentPage);\n  }, [fetchPage, currentPage]);\n\n  return {\n    // State\n    data,\n    totalPages,\n    totalItems,\n    currentPage,\n    loading,\n    error,\n    \n    // Actions\n    fetchPage,\n    goToPage,\n    nextPage,\n    prevPage,\n    refresh,\n    \n    // Utilities\n    hasNextPage: currentPage < totalPages,\n    hasPrevPage: currentPage > 1,\n    clearError: () => setError(null)\n  };\n};\n\n/**\n * Hook for managing data with search functionality\n * @param {Function} searchFunction - The search API function\n * @param {Object} options - Search options\n * @returns {Object} Search state and controls\n */\nexport const useSearch = (searchFunction, options = {}) => {\n  const { debounceMs = 300, minLength = 2 } = options;\n  \n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Debounced search effect\n  const [debounceTimer, setDebounceTimer] = useState(null);\n\n  const search = useCallback(async (searchQuery, filters = {}) => {\n    if (searchQuery.length < minLength) {\n      setResults([]);\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const data = await searchFunction(searchQuery, filters);\n      setResults(data);\n      return data;\n    } catch (err) {\n      setError(err.message || 'Search failed');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [searchFunction, minLength]);\n\n  const debouncedSearch = useCallback((searchQuery, filters = {}) => {\n    // Clear existing timer\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n\n    // Set new timer\n    const timer = setTimeout(() => {\n      search(searchQuery, filters);\n    }, debounceMs);\n\n    setDebounceTimer(timer);\n  }, [search, debounceMs, debounceTimer]);\n\n  const updateQuery = useCallback((newQuery) => {\n    setQuery(newQuery);\n    debouncedSearch(newQuery);\n  }, [debouncedSearch]);\n\n  const clearSearch = useCallback(() => {\n    setQuery('');\n    setResults([]);\n    setError(null);\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n  }, [debounceTimer]);\n\n  return {\n    // State\n    query,\n    results,\n    loading,\n    error,\n    \n    // Actions\n    search,\n    updateQuery,\n    clearSearch,\n    \n    // Utilities\n    hasResults: results.length > 0,\n    clearError: () => setError(null)\n  };\n};\n